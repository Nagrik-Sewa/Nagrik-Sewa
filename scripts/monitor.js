const axios = require('axios');
const fs = require('fs');
const path = require('path');

class SystemMonitor {
  constructor(config = {}) {
    this.config = {
      apiUrl: process.env.API_URL || 'http://localhost:8080',
      checkInterval: config.checkInterval || 30000, // 30 seconds
      alertThreshold: config.alertThreshold || 3, // 3 failed checks
      logFile: config.logFile || path.join(__dirname, '../logs/monitor.log'),
      ...config
    };
    
    this.consecutiveFailures = 0;
    this.lastHealthCheck = null;
    this.metrics = {
      uptime: 0,
      responseTime: [],
      memoryUsage: [],
      errorCount: 0,
      successCount: 0
    };
    
    this.initializeLogging();
  }\n  \n  initializeLogging() {\n    const logDir = path.dirname(this.config.logFile);\n    if (!fs.existsSync(logDir)) {\n      fs.mkdirSync(logDir, { recursive: true });\n    }\n  }\n  \n  log(level, message, data = {}) {\n    const timestamp = new Date().toISOString();\n    const logEntry = {\n      timestamp,\n      level,\n      message,\n      data\n    };\n    \n    console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);\n    \n    if (data && Object.keys(data).length > 0) {\n      console.log(JSON.stringify(data, null, 2));\n    }\n    \n    // Write to log file\n    fs.appendFileSync(this.config.logFile, JSON.stringify(logEntry) + '\\n');\n  }\n  \n  async healthCheck() {\n    const startTime = Date.now();\n    \n    try {\n      const response = await axios.get(`${this.config.apiUrl}/health`, {\n        timeout: 10000\n      });\n      \n      const responseTime = Date.now() - startTime;\n      const healthData = response.data;\n      \n      this.lastHealthCheck = {\n        status: 'healthy',\n        timestamp: new Date().toISOString(),\n        responseTime,\n        data: healthData\n      };\n      \n      this.metrics.responseTime.push(responseTime);\n      if (this.metrics.responseTime.length > 100) {\n        this.metrics.responseTime.shift(); // Keep only last 100 measurements\n      }\n      \n      this.metrics.successCount++;\n      this.consecutiveFailures = 0;\n      \n      this.log('info', 'Health check passed', {\n        responseTime: `${responseTime}ms`,\n        status: healthData.status,\n        database: healthData.database\n      });\n      \n      // Check for performance issues\n      if (responseTime > 5000) {\n        this.log('warn', 'Slow response detected', { responseTime: `${responseTime}ms` });\n      }\n      \n      // Check memory usage\n      if (healthData.memory) {\n        const memoryUsed = parseInt(healthData.memory.heapUsed);\n        this.metrics.memoryUsage.push(memoryUsed);\n        \n        if (memoryUsed > 512) { // 512MB threshold\n          this.log('warn', 'High memory usage detected', { \n            memoryUsed: healthData.memory.heapUsed \n          });\n        }\n      }\n      \n      return this.lastHealthCheck;\n      \n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      \n      this.lastHealthCheck = {\n        status: 'unhealthy',\n        timestamp: new Date().toISOString(),\n        responseTime,\n        error: error.message\n      };\n      \n      this.consecutiveFailures++;\n      this.metrics.errorCount++;\n      \n      this.log('error', 'Health check failed', {\n        error: error.message,\n        consecutiveFailures: this.consecutiveFailures,\n        responseTime: `${responseTime}ms`\n      });\n      \n      // Alert if threshold reached\n      if (this.consecutiveFailures >= this.config.alertThreshold) {\n        this.sendAlert(error);\n      }\n      \n      return this.lastHealthCheck;\n    }\n  }\n  \n  async getMetrics() {\n    try {\n      const response = await axios.get(`${this.config.apiUrl}/metrics`, {\n        timeout: 10000,\n        headers: {\n          Authorization: `Bearer ${process.env.METRICS_AUTH_TOKEN || ''}`\n        }\n      });\n      \n      return response.data;\n    } catch (error) {\n      this.log('error', 'Failed to fetch metrics', { error: error.message });\n      return null;\n    }\n  }\n  \n  sendAlert(error) {\n    const alertData = {\n      level: 'critical',\n      message: `Application health check failed ${this.consecutiveFailures} times`,\n      error: error.message,\n      timestamp: new Date().toISOString(),\n      lastSuccessfulCheck: this.metrics.successCount > 0 ? 'Available' : 'Never',\n      apiUrl: this.config.apiUrl\n    };\n    \n    this.log('alert', 'CRITICAL: Application may be down', alertData);\n    \n    // Here you would integrate with your alerting system\n    // Examples: Send email, Slack notification, PagerDuty, etc.\n    // this.sendSlackAlert(alertData);\n    // this.sendEmailAlert(alertData);\n  }\n  \n  generateReport() {\n    const avgResponseTime = this.metrics.responseTime.length > 0 \n      ? Math.round(this.metrics.responseTime.reduce((a, b) => a + b, 0) / this.metrics.responseTime.length)\n      : 0;\n    \n    const successRate = this.metrics.successCount + this.metrics.errorCount > 0\n      ? Math.round((this.metrics.successCount / (this.metrics.successCount + this.metrics.errorCount)) * 100)\n      : 0;\n    \n    return {\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      consecutiveFailures: this.consecutiveFailures,\n      metrics: {\n        totalChecks: this.metrics.successCount + this.metrics.errorCount,\n        successCount: this.metrics.successCount,\n        errorCount: this.metrics.errorCount,\n        successRate: `${successRate}%`,\n        averageResponseTime: `${avgResponseTime}ms`,\n        lastCheck: this.lastHealthCheck\n      }\n    };\n  }\n  \n  start() {\n    this.log('info', 'Starting system monitor', {\n      apiUrl: this.config.apiUrl,\n      checkInterval: `${this.config.checkInterval}ms`,\n      alertThreshold: this.config.alertThreshold\n    });\n    \n    // Initial health check\n    this.healthCheck();\n    \n    // Set up interval\n    this.interval = setInterval(() => {\n      this.healthCheck();\n    }, this.config.checkInterval);\n    \n    // Generate report every 5 minutes\n    this.reportInterval = setInterval(() => {\n      const report = this.generateReport();\n      this.log('info', 'System report', report);\n    }, 5 * 60 * 1000);\n    \n    // Graceful shutdown\n    process.on('SIGINT', () => {\n      this.stop();\n      process.exit(0);\n    });\n    \n    process.on('SIGTERM', () => {\n      this.stop();\n      process.exit(0);\n    });\n  }\n  \n  stop() {\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n    \n    if (this.reportInterval) {\n      clearInterval(this.reportInterval);\n    }\n    \n    this.log('info', 'System monitor stopped');\n  }\n}\n\n// CLI usage\nif (require.main === module) {\n  const monitor = new SystemMonitor({\n    apiUrl: process.argv[2] || process.env.API_URL || 'http://localhost:8080',\n    checkInterval: parseInt(process.argv[3]) || 30000,\n    alertThreshold: parseInt(process.argv[4]) || 3\n  });\n  \n  monitor.start();\n  \n  console.log('\\nüîç System Monitor Started');\n  console.log('Press Ctrl+C to stop\\n');\n}\n\nmodule.exports = SystemMonitor;